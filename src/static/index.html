<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maqam Detector 2.0 - Obsidian Web</title>
    <style>
        :root {
            --bg-color: #050505;
            --card-color: #1E1E1E;
            --primary: #00E5FF;
            --secondary: #FF0055;
            --text-color: #E0E0E0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        h1 {
            margin-top: 20px;
            letter-spacing: 2px;
            color: var(--primary);
        }

        .dashboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 20px;
        }

        .card {
            background-color: var(--card-color);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            width: 100%;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .prediction {
            font-size: 3em;
            font-weight: bold;
            color: var(--secondary);
            margin: 10px 0;
        }

        .scores {
            font-size: 0.8em;
            color: #888;
        }

        .chip {
            background: #333;
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }

        /* Visualizer */
        #chromaCanvas {
            background-color: #000;
            border-radius: 50%;
            border: 2px solid #222;
        }

        .upload-btn {
            margin-top: 20px;
            padding: 15px 30px;
            background: var(--primary);
            color: #000;
            border: none;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1em;
        }

        .upload-btn:hover {
            opacity: 0.9;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>

<body>

    <h1>MAQAM DETECTOR 2.0</h1>

    <div class="dashboard">
        <div class="card">
            <div>DETECTED MAQAM</div>
            <div class="prediction" id="maqamLabel">UNKNOWN</div>
            <div class="scores" id="scoresContainer">Waiting for audio...</div>
        </div>

        <canvas id="chromaCanvas" width="300" height="300"></canvas>

        <label class="upload-btn">
            UPLOAD WAV
            <input type="file" id="audioInput" accept=".wav">
        </label>
        <p id="status" style="margin-top:10px; font-size:0.8em; color:#555;">Status: Disconnected</p>
    </div>

    <script>
        const ws = new WebSocket("ws://" + window.location.host + "/ws/analyze");
        const statusEl = document.getElementById('status');
        const maqamLabel = document.getElementById('maqamLabel');
        const scoresContainer = document.getElementById('scoresContainer');
        const canvas = document.getElementById('chromaCanvas');
        const ctx = canvas.getContext('2d');

        ws.onopen = () => { statusEl.innerText = "Status: Connected"; statusEl.style.color = "lime"; };
        ws.onclose = () => { statusEl.innerText = "Status: Disconnected"; statusEl.style.color = "red"; };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.prediction) {
                maqamLabel.innerText = data.prediction.toUpperCase();

                // Scores
                scoresContainer.innerHTML = "";
                let scores = data.confidence || {};
                for (let k in scores) {
                    let s = document.createElement("span");
                    s.className = "chip";
                    s.innerText = k + ": " + parseFloat(scores[k]).toFixed(2);
                    scoresContainer.appendChild(s);
                }

                // Draw Visualizer
                drawVisualizer(data.chromagram, data.rukooz);
            }
        };

        function drawVisualizer(chroma, rukooz) {
            // Check dimensions. API sends [36, Time] or flattened list? 
            // In API we sent `chroma.tolist()`. If input is 1D array -> 1D list.
            // If input is 2D -> List of lists.

            let energy = new Array(36).fill(0);

            // Flatten logic
            if (Array.isArray(chroma[0])) {
                // 2D, define average
                for (let i = 0; i < 36; i++) {
                    let sum = 0;
                    for (let t = 0; t < chroma[0].length; t++) {
                        sum += chroma[i][t] || 0; // Check shape carefully
                    }
                    // Wait, librosa chroma is [bins, time]. So chroma[i] is the array for bin i.
                    // Correct.
                    if (chroma[i].length > 0)
                        energy[i] = chroma[i].reduce((a, b) => a + b, 0) / chroma[i].length;
                }
            } else {
                energy = chroma;
            }

            // Normalize
            let maxE = Math.max(...energy) || 1;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = 100;
            const barMax = 40;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw
            for (let i = 0; i < 36; i++) {
                let angle = (i * (2 * Math.PI / 36)) - (Math.PI / 2);
                let val = energy[i] / maxE;
                let barLen = val * barMax;

                // Color
                ctx.strokeStyle = (i === rukooz) ? "#FF0055" : `rgba(0, 229, 255, ${0.3 + val * 0.7})`;
                ctx.lineWidth = 4;
                ctx.lineCap = "round";

                ctx.beginPath();
                ctx.moveTo(
                    cx + Math.cos(angle) * (radius),
                    cy + Math.sin(angle) * (radius)
                );
                ctx.lineTo(
                    cx + Math.cos(angle) * (radius + barLen + 5),
                    cy + Math.sin(angle) * (radius + barLen + 5)
                );
                ctx.stroke();

                // Grid markers
                if (i % 3 === 0) {
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.arc(
                        cx + Math.cos(angle) * (radius + barMax + 15),
                        cy + Math.sin(angle) * (radius + barMax + 15),
                        2, 0, 2 * Math.PI
                    );
                    ctx.fill();
                }
            }
        }

        // Upload handler
        document.getElementById('audioInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            // Read as ArrayBuffer and send
            const reader = new FileReader();
            reader.onload = (evt) => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(evt.target.result);
                } else {
                    alert("WebSocket not connected!");
                }
            };
            reader.readAsArrayBuffer(file);
        });

    </script>
</body>

</html>